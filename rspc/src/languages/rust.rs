//! TODO: Bring this back when published.
// use std::{borrow::Cow, collections::HashMap, path::Path};

// use specta::datatype::DataType;
// use specta_typescript::ExportError;

// use crate::{procedure::ProcedureType, types::TypesOrType, ProcedureKind, Types};

// pub struct Rust(()); // TODO: specta_rust::Rust

// // TODO: Traits - `Debug`, `Clone`, etc

// impl Default for Rust {
//     fn default() -> Self {
//         Self(()) // TODO: specta_typescript::Typescript::default().framework_header("// This file was generated by [rspc](https://github.com/specta-rs/rspc). Do not edit this file manually.")
//     }
// }

// impl Rust {
//     // TODO: Clone all methods from `specta_rust::Rust`

//     pub fn export_to(&self, path: impl AsRef<Path>, types: &Types) -> Result<(), ExportError> {
//         std::fs::write(path, self.export(types)?)?;
//         // TODO: Format file
//         Ok(())
//     }

//     pub fn export(&self, types: &Types) -> Result<String, ExportError> {
//         println!("WARNING: `rspc::Rust` is an unstable feature! Use at your own discretion!");

//         let mut s = "//! This file was generated by [rspc](https://github.com/specta-rs/rspc). Do not edit this file manually.\n\npub struct Procedures;\n\n".to_string();

//         // TODO: Move to `specta_rust::Rust` which should handle this like we do with Typescript.
//         for (_, ty) in types.types.into_iter() {
//             s.push_str(&specta_rust::export_named_datatype(ty).unwrap())
//         }

//         // TODO: disabling warning on the output???

//         for (key, item) in types.procedures.clone().into_iter() {
//             export(&mut s, key.to_string(), key, item);
//         }

//         Ok(s)
//     }
// }

// fn export(s: &mut String, full_key: String, ident: Cow<'static, str>, item: TypesOrType) {
//     match item {
//         TypesOrType::Type(ty) => {
//             let kind = match ty.kind {
//                 ProcedureKind::Query => "Query",
//                 ProcedureKind::Mutation => "Mutation",
//                 ProcedureKind::Subscription => "Subscription",
//             };

//             let input = specta_rust::datatype(&ty.input).unwrap();
//             let output = specta_rust::datatype(&ty.output).unwrap();
//             let error = "()"; // TODO: specta_rust::datatype(&ty.error).unwrap();

//             s.push_str(&format!(
//                 r#"pub struct {ident};

// impl rspc_client::Procedure for {ident} {{
//     type Input = {input};
//     type Output = {output};
//     type Error = {error};
//     type Procedures = Procedures;
//     const KIND: rspc_client::ProcedureKind = rspc_client::ProcedureKind::{kind};
//     const KEY: &'static str = "{ident}";
// }}

// "#
//             ));
//         }
//         TypesOrType::Types(inner) => {
//             for (key, item) in inner {
//                 s.push_str(&format!("\npub mod {key} {{\n"));
//                 s.push_str(&"\tpub use super::Procedures;\n");
//                 export(s, format!("{full_key}.{key}"), key, item); // TODO: Inset all items by the correct nuber of tabs
//                 s.push_str("}\n");
//             }
//         }
//     }
// }
