use std::{borrow::Cow, collections::HashMap, path::Path};

use specta::datatype::DataType;
use specta_typescript::ExportError;

use crate::{procedure::ProcedureType, ProcedureKind, Types};

pub struct Rust(()); // TODO: specta_rust::Rust

// TODO: Traits - `Debug`, `Clone`, etc

impl Default for Rust {
    fn default() -> Self {
        Self(()) // TODO: specta_typescript::Typescript::default().framework_header("// This file was generated by [rspc](https://github.com/specta-rs/rspc). Do not edit this file manually.")
    }
}

impl Rust {
    // TODO: Clone all methods from `specta_rust::Rust`

    pub fn export_to(&self, path: impl AsRef<Path>, types: &Types) -> Result<(), ExportError> {
        std::fs::write(path, self.export(types)?)?;
        // TODO: Format file
        Ok(())
    }

    pub fn export(&self, types: &Types) -> Result<String, ExportError> {
        println!("WARNING: `rspc::Rust` is an unstable feature! Use at your own discretion!");

        let mut s = "//! This file was generated by [rspc](https://github.com/specta-rs/rspc). Do not edit this file manually.\n\n".to_string();

        // TODO: Move to `specta_rust::Rust` which should handle this like we do with Typescript.
        for (_, ty) in types.types.into_iter() {
            s.push_str(&specta_rust::export_named_datatype(ty).unwrap())
        }

        // TODO: disabling warning on the output???

        // TODO: We should probs always store procedures as tree
        let mut tree = HashMap::new();
        for (key, ty) in types.procedures.iter() {
            let mut current = &mut tree;
            for part in &key[..(key.len() - 1)] {
                let a = current
                    .entry(part.clone())
                    .or_insert_with(|| Todo::Module(HashMap::new()));
                match a {
                    Todo::Procedure(_, _, _) => todo!(),
                    Todo::Module(hash_map) => current = hash_map,
                }
            }
            current.insert(
                key[key.len() - 1].clone(),
                Todo::Procedure(
                    key.join(".").to_string(),
                    key[key.len() - 1].clone(),
                    ty.clone(),
                ),
            );
        }

        for item in tree {
            export(&mut s, item.1);
        }

        Ok(s)
    }
}

enum Todo {
    Procedure(String, Cow<'static, str>, ProcedureType),
    Module(HashMap<Cow<'static, str>, Todo>),
}

fn export(s: &mut String, item: Todo) {
    match item {
        Todo::Procedure(key, ident, ty) => {
            let kind = match ty.kind {
                ProcedureKind::Query => "Query",
                ProcedureKind::Mutation => "Mutation",
                ProcedureKind::Subscription => "Subscription",
            };

            let input = specta_rust::datatype(&ty.input).unwrap();
            let output = specta_rust::datatype(&ty.output).unwrap();
            let error = "()"; // TODO: specta_rust::datatype(&ty.error).unwrap();

            s.push_str(&format!(
                r#"pub struct {ident};

impl rspc_client::Procedure for {ident} {{
    type Input = {input};
    type Output = {output};
    type Error = {error};
    const KIND: rspc_client::ProcedureKind = rspc_client::ProcedureKind::{kind};
    const KEY: &'static str = "{key}";
}}

"#
            ));
        }
        Todo::Module(inner) => {
            for (key, item) in inner {
                s.push_str(&format!("\npub mod {key} {{\n"));
                export(s, item); // TODO: Inset all items by the correct nuber of tabs
                s.push_str("}\n");
            }
        }
    }
}
